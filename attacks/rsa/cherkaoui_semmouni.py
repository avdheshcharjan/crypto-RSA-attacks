import logging
import os
import sys
from math import isqrt
from math import log
from math import sqrt

from sage.all import RR
from sage.all import ZZ

path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.realpath(os.path.abspath(__file__)))))
if sys.path[1] != path:
    sys.path.insert(1, path)

from shared.small_roots import herrmann_may


def attack(N, e, beta, delta, m=1, t=None, check_bounds=True):
    """
    Recovers the prime factors of a modulus and the private exponent if |p - q| is sufficiently small.
    More information: Cherkaoui-Semmouni M. et al., "Cryptanalysis of RSA Variants with Primes Sharing Most Significant Bits"
    :param N: the modulus
    :param e: the exponent
    :param beta: the parameter beta such that |p - q| <= N^beta
    :param delta: the parameter delta such that d <= N^delta
    :param m: the m value to use for the small roots method (default: 1)
    :param t: the t value to use for the small roots method (default: automatically computed using m)
    :param check_bounds: perform bounds check (default: True)
    :return: a tuple containing the prime factors and the private exponent, or None if the factors could not be found
    """
    alpha = log(e, N)
    assert not check_bounds or delta < 2 - sqrt(2 * alpha * beta), f"Bounds check failed ({delta} < {2 - sqrt(2 * alpha * beta)})."

    x, y = ZZ["x", "y"].gens()
    A = -(N - 1) ** 2
    f = x * y + A * x + 1
    X = int(2 * e * RR(N) ** (delta - 2))  # Equivalent to 2N^(alpha + delta - 2)
    Y = int(RR(N) ** (2 * beta))
    t = int((2 - delta - 2 * beta) / (2 * beta) * m) if t is None else t
    logging.info(f"Trying {m = }, {t = }...")
    for x0, y0 in herrmann_may.modular_bivariate(f, e, m, t, X, Y):
        s = isqrt(y0)
        d = s ** 2 + 4 * N
        p = int(-s + isqrt(d)) // 2
        q = int(s + isqrt(d)) // 2
        d = int(f(x0, y0) // e)
        return p, q, d

    return None

# N = 128589061281216285853837590229440770955825203399513062599649256749518249026659493745707806280644334023658643574788289442948320279604443873469632216265484067747892483276745385742755630919868729974993119460006139069495990256036575129572429240020088970983911478514457962357010751696116678580453222755164299218549
# # works perfectly
# # doesnt work coz no rootsN=60823785598978114459958581268840513318966595087249212058136830110757174855782546322670721881300832872993349053980109673439422488528872403612648884635771696173053942505491012385767224597916479254890576886218228806352521769900372663349835559871671746484829007579243651088378744266046647219850861135210163285693

# # N=68595459708599929960868517951775687813834103965138013705653032565442509729315425676054989085679079110776940478934809139499879095677996642112137738245257357432269999540527573982158030378683779245399842893573854543350926696905566475175828883113125167692239054270685175963423243738674642752068793541640300446949
# e = 656004714415520925304508553062370903160906373260831418376155234031103953028701728516709845078613446850436012766664203901926239975184100878753982194671184344505363800201667709052712179034821539184811191176529116980190742276358408178606066309312751094947345719752727377127867556038310739729060906061649394093586530631375649773615277283004263492460300787257925544540880532938726325093230854039509246401675172466582706119200957333207569754235900939815154013060113002778680466566882320776451125153612349115209357634306021723449044334437447021870514950670965340761003414186271235218807491067981771194625563633604657797629
# beta = 0.5
# delta = 0.54

# # p, q = attack(N, e, beta, delta)
# p, q, d = attack(N, e, beta, delta, m=5)
# assert p * q == N
# print(f"Found {p = } , {q = } and {d= }")

p = 6970095733639071098312656967411917275080643486698328141048794358773925405193762089371592275422356527243822408600697915626180888948121089544657377661918979
q = 18449203001167453683629192798359337118936602406279119934040327468259582280616884846975771623742879592317716054643763931279691320991968677567970772946431553
N = p * q
e = 656004714415520925304508553062370903160906373260831418376155234031103953028701728516709845078613446850436012766664203901926239975184100878753982194671184344505363800201667709052712179034821539184811191176529116980190742276358408178606066309312751094947345719752727377127867556038310739729060906061649394093586530631375649773615277283004263492460300787257925544540880532938726325093230854039509246401675172466582706119200957333207569754235900939815154013060113002778680466566882320776451125153612349115209357634306021723449044334437447021870514950670965340761003414186271235218807491067981771194625563633604657797629
d = pow(e, -1, (p ** 2 - 1) * (q ** 2 - 1))
beta = 0.5
delta = 0.54
p_, q_, d_ = attack(N, e, beta, delta, m=5)
 
assert p * q == N
assert d_ == d
assert isinstance(p_, int), "p_ is not an instance of int"
assert isinstance(q_, int), "q_ is not an instance of int"
assert isinstance(d_, int), "d_ is not an instance of int"
assert N == p_ * q_, f"N is not equal to p_ * q_ (N={N}, p_={p_}, q_={q_})"
assert d == d_, f"d is not equal to d_ (d={d}, d_={d_})"

print(f"Found {p = } and {q = } and {d= }")